# 무인 주문 웹앱 PRD (Product Requirement Document)

## 1. 개요
- **프로젝트명**: 아토키토 터치(ATOKETO TOUCH)
- **목적**: 고객이 매장에서 직접 웹앱으로 주문서를 작성하여 출력한 후, 해당 주문서를 통해 결제를 진행할 수 있는 **무인 주문 시스템**을 구축하는 것  
- **대상 사용자**: 매장 방문 고객 및 매장 운영 관리자  
- **주요 기능**:  
  - 고객이 메뉴를 선택하고 원하는 옵션을 조합하여 **주문서**를 생성  
  - 생성된 주문서를 매장에서 **출력** (프린터 인쇄)  
  - 출력된 주문서를 매장 **카운터에서 결제** 진행  
  - 관리자가 메뉴를 추가/삭제하고 **메뉴 사진을 업로드**할 수 있는 관리자 페이지 제공  

## 2. 기능 요구사항

### 2.1 고객용 기능
1. **메뉴 선택**  
   - 기본 메뉴 선택 (예: *수비드 비프 포케*)  
   - [필수] 메인 토핑 옵션 선택 (예: 100g, 200g 중 택일)  
   - [필수] 기본 드레싱 옵션 선택 (예: 소스 없음, 오리엔탈, 발사믹, 어니언, 허니머스타드, 쓰리라차마요,참깨 중 택일)  
   - [선택] 메인 토핑 추가 옵션 선택 (예: 수비드 닭가슴살, 수비드 비프, 훈제오리, 돼지갈비, 훈제연어, 대왕쉬림프(무염버터))  
   - [선택] 사이드 토핑 추가 옵션 선택 (예: 현미밥, 크래미, 옥수수콘, 올리브, 병아리콩, 할라피뇨, 양파+양파튀김, 메추리알, 방울토마토, 눈꽃치즈, 구운버섯, 아보카도)
   - [선택] 드레싱 추가 (예: 오리엔탈, 발사믹, 어니언, 허니머스타드, 쓰리라차마요,참깨)
   - **오프라인 동작 지원**: 네트워크 연결이 불안정한 상황에서도 기본 기능 동작 보장
   - **사용자 입력 검증**: 모든 필수 선택 항목에 대한 유효성 검사와 실시간 피드백 제공
   - **기본 메뉴별 옵션 기본값 설정**: 수비드 비프 포케(기본 드레싱 옵션: 사우전아일랜드 기본 선택), 머슬도시락(기본 드레싱 옵션: 소스없음 기본 선택 등)

2. **주문서 확인**  
   - 고객이 선택한 메뉴 및 옵션을 실시간으로 화면 하단에 요약 표시  
   - 선택한 항목과 수량에 따른 **총 주문 금액**을 자동 계산하여 표시  
   - **주문 수정 기능**: 최종 확인 단계에서 쉬운 수정 경로 제공
   - **주문 상세 미리보기**: 출력될 주문서 양식 미리보기 제공

3. **주문서 출력**  
   - 주문 내용 최종 확인 후 **주문서 출력** 기능 제공  
   - 고객은 출력된 주문서를 가지고 매장 카운터에서 **결제 진행**  
   - **프린터 상태 체크**: 출력 전 프린터 연결 상태 및 용지 확인
   - **대체 출력 방안**: 프린터 장애 시 QR코드나 주문번호 발급 등 대체 방안 구현
   - **주문 ID 생성**: 고유한 주문 식별자 생성 및 바코드/QR코드로 인코딩

### 2.2 관리자용 기능
1. **메뉴 관리**  
   - 새로운 메뉴 **추가** 기능 (메뉴 이름, 설명, 가격 등 입력)  
   - 기존 메뉴 **삭제/수정** 기능  
   - 메뉴별 **사진 업로드** 및 변경 기능 (이미지 파일 업로드)  
   - **이미지 최적화**: 자동 이미지 리사이징, 업로드 시 메뉴판 비율 클립 편집 기능 제공, 압축 및 캐싱 시스템 구현
   - **메뉴 구성 템플릿**: 일관된 메뉴 구성을 위한 템플릿 제공
   - **메뉴별 옵션 기본값 개별설정**: 메인 메뉴별 기본값을 입력하여 추천 소스 등이 기본으로 선택되어 고객들이 편리하게 주문을 할 수도록 세팅

2. **옵션 관리**  
   - 메인 토핑, 소스, 추가 토핑 옵션 목록 **관리** (옵션 항목 추가/삭제/수정)  
   - 각 옵션별 추가 가격 설정 및 변경 기능  
   - **옵션 의존성 관리**: 특정 메뉴에만 적용되는 옵션 설정 가능
   - **옵션 그룹화**: 관련 옵션의 논리적 그룹화 지원

3. **주문 기록 관리**
   - 고객이 출력한 주문서의 내역을 저장하고, 관리자 대시보드에서 실시간 **로그 확인**
   - 기간별 주문 건수, 인기 메뉴 등의 **통계 조회** 기능 및 데이터 시각화
   - **데이터 내보내기**: CSV/Excel 형식으로 주문 데이터 내보내기 기능
   - **재고 연동 기능**: 주문량에 따른 재고 자동 계산 및 경고 시스템 (선택사항)

4. **시스템 설정**
   - **프린터 설정**: 네트워크/블루투스 프린터 연결 관리 및 테스트
   - **영업시간 설정**: 영업 시간 외 주문 제한 설정
   - **계정 관리**: 관리자 계정 생성 및 권한 설정
   - **백업 및 복원**: 시스템 데이터 백업 및 복원 기능

## 3. 아키텍처 및 기술 스택

### 3.1 프론트엔드
- **기본 프레임워크**: React.js (Next.js)를 활용한 SSR/SSG 하이브리드 구현
  - 이유: 초기 로딩 성능과 SEO 최적화, 개발 생산성 향상
- **상태 관리**: Redux Toolkit 또는 React Query + Context API
  - 이유: 복잡한 주문 상태 및 전역 상태 효율적 관리
- **UI 라이브러리**: Tailwind CSS + 커스텀 컴포넌트 시스템
  - 이유: 디자인 일관성 유지 및 효율적인 스타일링
- **타입 안전성**: TypeScript 전면 적용
  - 이유: 런타임 오류 감소 및 코드 품질 향상
- **테스팅**: Jest + React Testing Library + Cypress
  - 이유: 단위, 통합, E2E 테스트를 통한 품질 보증

### 3.2 백엔드
- **기본 인프라**: Supabase (PostgreSQL + 서버리스 함수)
  - 이유: 초기 개발 속도와 관리 편의성
- **API 설계**: RESTful + GraphQL 하이브리드 접근
  - 이유: 데이터 요청 최적화 및 유연성 확보
- **인증/인가**: JWT 기반 인증 시스템 + Role 기반 접근 제어
  - 이유: 안전한 관리자 시스템 액세스 제어
- **확장 고려**: 마이크로서비스 전환 가능성을 고려한 모듈형 설계
  - 이유: 향후 트래픽 증가 시 효율적 스케일링

### 3.3 데이터베이스
- **기본 DB**: PostgreSQL (Supabase 제공)
  - 이유: 강력한 쿼리 기능과 관계형 데이터 모델링 지원
- **데이터 모델**: 
  - `menus`: 메뉴 기본 정보 (id, name, description, base_price, image_url)
  - `options`: 옵션 정보 (id, name, price, category, available)
  - `menu_options`: 메뉴-옵션 연결 테이블 (menu_id, option_id, required)
  - `orders`: 주문 정보 (id, created_at, total_price, status)
  - `order_items`: 주문 상세 항목 (order_id, menu_id, quantity, subtotal)
  - `order_item_options`: 주문 항목별 옵션 (order_item_id, option_id)
- **캐싱 전략**: Redis 도입 고려 (인기 메뉴 및 옵션 캐싱)
  - 이유: 반복되는 메뉴 조회 성능 최적화

### 3.4 인프라 및 배포
- **호스팅**: Vercel (프론트엔드), Supabase (백엔드 + DB)
  - 이유: CI/CD 자동화 및 글로벌 CDN 활용
- **컨테이너화**: Docker 기반 로컬 개발 환경 구성
  - 이유: 개발-배포 환경 일관성 확보
- **모니터링**: Sentry (오류 추적) + Vercel Analytics + PostHog (행동 분석)
  - 이유: 실시간 오류 감지 및 사용자 행동 분석
- **보안**: HTTPS 적용, API 요청 제한, 입력 데이터 유효성 검증
  - 이유: 기본적인 보안 취약점 방지

## 4. 프린터 연동 전략

### 4.1 프린터 시스템 구성
- **지원 프린터 타입**: 
  1. 네트워크 프린터 (IP 기반)
  2. 블루투스 프린터 (모바일 환경)
  3. USB 연결 프린터 (전용 태블릿 사용 시)
- **통합 방식**:
  1. **웹 기반 인쇄**: 주문 데이터를 HTML/PDF로 변환 후 브라우저 인쇄 API 활용
  2. **로컬 프린트 서버**: 전용 경량 Node.js 프린트 서버를 매장 기기에 설치
  3. **클라우드 프린트**: Google Cloud Print 또는 유사 서비스 연동 (대체 방안)

### 4.2 장애 대응 방안
- **프린터 상태 모니터링**: 정기적 프린터 상태 체크 및 알림
- **프린터 장애 시 대체 플로우**: 
  1. 화면에 주문 QR 코드 표시
  2. 주문 번호 발급 및 SMS 전송 옵션
  3. 이메일 영수증 발송 기능
- **로그 및 복구**: 모든 출력 시도 기록 및 실패 시 자동 재시도 메커니즘

## 5. 개발 및 품질 보증 전략

### 5.1 개발 단계 및 우선순위
1. **MVP 단계 (1-2주)**:
   - 기본 메뉴 표시 및 선택 기능
   - 간단한 주문서 생성 및 브라우저 인쇄
   - 최소 관리자 기능 (메뉴 추가/수정)

2. **알파 버전 (3-4주)**:
   - 전체 고객 주문 플로우 구현
   - 프린터 연동 기본 구현
   - 기본 관리자 대시보드

3. **베타 버전 (5-6주)**:
   - 전체 관리자 기능 구현
   - 통계 및 분석 기능
   - 오류 처리 및 안정화

4. **프로덕션 버전 (7-8주)**:
   - 성능 최적화
   - 보안 강화
   - 프린터 장애 대응 체계 완성

### 5.2 테스트 전략
- **단위 테스트**: 핵심 비즈니스 로직 및 유틸리티 함수 (Jest)
- **통합 테스트**: API 호출 및 상태 관리 흐름 (React Testing Library)
- **E2E 테스트**: 주요 사용자 흐름 시나리오 (Cypress)
- **부하 테스트**: 동시 다수 주문 상황 시뮬레이션 (k6)
- **프린터 호환성 테스트**: 다양한 프린터 모델 및 환경에서 테스트

### 5.3 코드 품질 관리
- **정적 분석**: ESLint + TypeScript + Prettier + SonarQube
- **코드 리뷰**: PR 기반 코드 리뷰 프로세스 수립
- **문서화**: OpenAPI 명세, JSDoc, Storybook을 활용한 컴포넌트 문서화
- **CI/CD**: GitHub Actions를 통한 테스트 자동화 및 배포 파이프라인

## 6. Figma 협업 워크플로우

### 6.1 디자인 시스템 구축
- **컴포넌트 라이브러리**: Figma 컴포넌트 및 변수 시스템 구축
- **디자인 토큰**: 색상, 타이포그래피, 간격 등의 디자인 토큰 정의
- **자동화 도구**: Figma to Code 변환 도구 활용 (Figma Tokens, Tailwind Config)

### 6.2 개발-디자인 협업 프로세스
1. **디자인 핸드오프**: Figma Inspect 기능을 통한 정확한 디자인 스펙 전달
2. **컴포넌트 동기화**: Figma 컴포넌트와 React 컴포넌트 간 1:1 매핑
3. **피드백 루프**: Figma 코멘트 기능을 활용한 디자인-개발 피드백
4. **디자인 QA**: 구현된 UI와 디자인 비교 검증 프로세스

### 6.3 반응형 디자인 고려사항
- **브레이크포인트 정의**: 모바일, 태블릿, 데스크톱 등 주요 화면 크기별 레이아웃
- **컴포넌트 응답성**: 화면 크기에 따른 컴포넌트 동작 정의
- **테스트 방법론**: 다양한 디바이스 환경에서의 검증 방법

## 7. 유지보수 및 확장성 고려사항

### 7.1 코드 구조 및 아키텍처
- **모듈형 설계**: 기능별 독립적 모듈로 분리 (메뉴 관리, 주문 처리, 프린팅 등)
- **확장 가능한 API**: 향후 기능 확장을 고려한 API 설계
- **특징 플래그**: 기능 토글을 통한 점진적 출시 지원

### 7.2 성능 최적화
- **이미지 최적화**: 자동 리사이징, WebP 변환, 지연 로딩
- **번들 최적화**: 코드 스플리팅, 트리 쉐이킹, 청크 관리
- **네트워크 최적화**: 데이터 프리페칭, 캐싱 전략

### 7.3 향후 확장 로드맵
- **모바일 앱 전환**: PWA 구현 및 네이티브 앱 전환 준비
- **결제 통합**: POS 시스템 또는 온라인 결제 통합 준비
- **멀티 매장 지원**: 다중 지점 관리 기능 설계
- **고객 회원 시스템**: 로열티 프로그램 및 개인화 기능 준비
- **AI 추천 엔진**: 주문 패턴 기반 메뉴 추천 시스템 (선택사항)

## 8. 보안 고려사항

### 8.1 데이터 보안
- **암호화**: 중요 데이터 암호화 (관리자 자격 증명 등)
- **데이터 접근 제어**: 역할 기반 접근 제어 (RBAC) 구현
- **개인정보 보호**: 불필요한 개인정보 수집 최소화 및 처리 정책

### 8.2 애플리케이션 보안
- **입력 검증**: 모든 사용자 입력에 대한 클라이언트 및 서버 측 유효성 검사
- **CSRF/XSS 방어**: 보안 헤더 및 토큰 구현
- **API 보안**: 속도 제한, 요청 크기 제한, 인증 토큰 만료 관리

### 8.3 인프라 보안
- **HTTPS 적용**: 모든 통신에 SSL/TLS 적용
- **정기적 업데이트**: 의존성 패키지 취약점 스캔 및 업데이트
- **백업 전략**: 정기적 데이터 백업 및 복구 테스트

## 9. 모니터링 및 지원 체계

### 9.1 성능 모니터링
- **애플리케이션 성능**: 주요 페이지 로딩 시간, API 응답 시간 추적
- **오류 모니터링**: Sentry를 통한 실시간 오류 추적 및 알림
- **사용자 행동 분석**: 주문 패턴, 드롭오프 포인트 분석

### 9.2 장애 대응 계획
- **인시던트 대응 프로세스**: 장애 감지, 분류, 대응, 해결 프로세스 정의
- **롤백 메커니즘**: 배포 문제 발생 시 신속한 롤백 체계
- **비상 연락망**: 주요 문제 발생 시 담당자 연락 체계

## 10. 구현 리스크 및 완화 전략

### 10.1 주요 기술적 리스크
1. **프린터 연동 복잡성**: 다양한 프린터 모델 및 드라이버 호환성 문제
   - **완화 전략**: 표준화된 인쇄 프로토콜 사용, 대체 출력 방법 구현
   
2. **네트워크 불안정성**: 매장 내 네트워크 상태에 따른 서비스 중단
   - **완화 전략**: 오프라인 기능 구현, 로컬 데이터 저장 및 동기화

3. **동시 다중 사용자 처리**: 성수기/피크 시간대 다수 주문 처리
   - **완화 전략**: 부하 테스트 및 스케일링 전략 수립

### 10.2 일정 리스크
1. **디자인-개발 조율**: UI/UX 디자인 변경으로 인한 개발 지연
   - **완화 전략**: 초기 프로토타입 합의 및 점진적 디자인 개선

2. **3rd 파티 의존성**: 외부 라이브러리 및 API 의존에 따른 지연
   - **완화 전략**: 핵심 기능에 대한 대체 구현방안 준비